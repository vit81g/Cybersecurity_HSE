import os  # Импортируем модуль os для работы с файловой системой
from typing import List  # Импортируем List для аннотаций типов

# Фиксированная таблица замен (S-box) из ГОСТ Р 34.12-2015, Приложение А
# Это 8 строк по 16 значений (от 0 до 15), используется для подстановки 4-битовых кусков
SBOX: List[List[int]] = [
    [12, 4, 6, 2, 10, 5, 11, 9, 14, 8, 13, 7, 0, 3, 15, 1],  # \(\pi_0\): первая строка таблицы
    [6, 8, 2, 3, 9, 10, 5, 12, 1, 11, 7, 13, 0, 4, 15, 14],  # \(\pi_1\): вторая строка таблицы
    [7, 11, 5, 8, 12, 4, 2, 0, 14, 1, 3, 10, 9, 15, 6, 13],  # \(\pi_2\): третья строка таблицы
    [13, 1, 7, 4, 11, 5, 0, 15, 3, 12, 14, 6, 9, 10, 2, 8],  # \(\pi_3\): четвёртая строка таблицы
    [5, 10, 15, 12, 1, 13, 14, 11, 8, 3, 6, 0, 4, 7, 9, 2],  # \(\pi_4\): пятая строка таблицы
    [14, 5, 0, 15, 13, 11, 3, 6, 9, 2, 12, 7, 1, 8, 10, 4],  # \(\pi_5\): шестая строка таблицы
    [11, 13, 12, 3, 7, 14, 10, 5, 0, 9, 4, 15, 2, 8, 1, 6],  # \(\pi_6\): седьмая строка таблицы
    [15, 12, 9, 7, 3, 0, 11, 4, 1, 14, 2, 13, 6, 10, 8, 5]  # \(\pi_7\): восьмая строка таблицы
]


def generate_round_keys(key: bytes) -> List[int]:
    """
    Генерирует 32 раундовых ключа из 256-битного исходного ключа для шифра Магма.
    Аргументы: key (bytes): Исходный ключ длиной 256 бит (32 байта).
    Возвращает: List[int]: Список из 32 раундовых ключей, каждый по 32 бита.
    Обработка ошибок: ValueError: Если длина ключа не равна 32 байтам.
    """
    # Проверяем, что длина ключа ровно 256 бит (32 байта)
    if len(key) != 32:
        raise ValueError("Ключ должен быть длиной 256 бит (32 байта)")

    round_keys: List[int] = []  # Создаём пустой список для хранения 8 базовых ключей

    # Делим исходный ключ на 8 частей по 4 байта (32 бита)
    for i in range(0, 32, 4):
        # Берем срез байтов от i до i+4 (например, 0-3, 4-7 и т.д.)
        chunk: bytes = key[i:i + 4]
        # Преобразуем 4 байта в 32-битовое целое число (big-endian — старшие байты слева)
        k: int = int.from_bytes(chunk, 'big')
        # Добавляем ключ в список
        round_keys.append(k)

    # Формируем расписание ключей согласно ГОСТ Р 34.12-2015:
    # Первые 24 раунда — ключи 0-7 повторяются трижды (8 × 3 = 24)
    # Последние 8 раундов — ключи 7-0 в обратном порядке
    schedule: List[int] = round_keys * 3 + round_keys[::-1]

    # Возвращаем полный список из 32 ключей
    return schedule


def G(a: int, k: int) -> int:
    """
    Функция преобразования G в сети Фейстеля для шифра Магма.
    Аргументы: a (int): Правая часть блока (32 бита); k (int): Раундовый ключ (32 бита).
    Возвращает: int: Результат преобразования (32 бита).
    """
    # Складываем входное значение a и ключ k по модулю 2^32 (максимум 32-битного числа)
    t: int = (a + k) % (2 ** 32)

    # Выполняем циклический сдвиг влево на 11 бит:
    # Сдвигаем t влево на 11 позиций
    left_shift: int = t << 11
    # Сдвигаем t вправо на 21 позицию (32 - 11 = 21), чтобы взять старшие биты
    right_shift: int = t >> 21
    # Объединяем результаты сдвигов побитовым ИЛИ и ограничиваем 32 битами
    t = (left_shift | right_shift) & 0xFFFFFFFF

    # Инициализируем переменную для результата подстановки
    result: int = 0

    # Применяем таблицу замен SBOX к каждому 4-битовому куску (нибблу)
    for i in range(8):
        # Извлекаем i-й 4-битовый кусок из t:
        # Сдвигаем вправо на 4*i позиций и берём младшие 4 бита (маска 0xF)
        nibble: int = (t >> (4 * i)) & 0xF
        # Выполняем подстановку: выбираем значение из i-й строки SBOX по индексу nibble
        subst: int = SBOX[i][nibble]
        # Сдвигаем подставленное значение на нужную позицию и добавляем к результату
        result |= (subst << (4 * i))

    # Возвращаем преобразованное 32-битовое значение
    return result


def encrypt_block(block: bytes, round_keys: List[int]) -> bytes:
    """
    Шифрует один 64-битовый блок данных с использованием шифра Магма.
    Аргументы: block (bytes): Входной блок длиной 64 бита (8 байт); round_keys (List[int]): Список из 32 раундовых ключей.
    Возвращает: bytes: Зашифрованный блок (8 байт).
    Обработка ошибок: ValueError: Если длина блока не равна 8 байтам.
    """
    # Проверяем, что длина блока точно 64 бита (8 байт)
    if len(block) != 8:
        raise ValueError("Блок должен быть длиной 64 бита (8 байт)")

    # Разделяем блок на две части по 32 бита:
    # Левую часть (L) — первые 4 байта
    L: int = int.from_bytes(block[:4], 'big')
    # Правую часть (R) — последние 4 байта
    R: int = int.from_bytes(block[4:], 'big')

    # Выполняем 32 раунда сети Фейстеля
    for i in range(32):
        # Сохраняем текущую правую часть, так как она станет новой левой
        old_R: int = R
        # Новая правая часть: старая левая XOR результат функции G от правой и ключа
        R = L ^ G(R, round_keys[i])
        # Новая левая часть: старая правая
        L = old_R

    # Собираем зашифрованный блок: сначала R, затем L (поменяли местами после раундов)
    encrypted: bytes = R.to_bytes(4, 'big') + L.to_bytes(4, 'big')

    # Возвращаем 8 байт зашифрованного блока
    return encrypted


def decrypt_block(block: bytes, round_keys: List[int]) -> bytes:
    """
    Расшифровывает один 64-битовый блок данных с использованием шифра Магма.
    Аргументы: block (bytes): Входной блок длиной 64 бита (8 байт); round_keys (List[int]): Список из 32 раундовых ключей.
    Возвращает: bytes: Расшифрованный блок (8 байт).
    Обработка ошибок: ValueError: Если длина блока не равна 8 байтам.
    """
    # Проверяем, что длина блока точно 64 бита (8 байт)
    if len(block) != 8:
        raise ValueError("Блок должен быть длиной 64 бита (8 байт)")

    # Разделяем блок на две части по 32 бита:
    # Левую часть (L) — первые 4 байта
    L: int = int.from_bytes(block[:4], 'big')
    # Правую часть (R) — последние 4 байта
    R: int = int.from_bytes(block[4:], 'big')

    # Выполняем 32 раунда в обратном порядке ключей
    for i in range(31, -1, -1):
        # Сохраняем текущую правую часть
        old_R: int = R
        # Новая правая часть: старая левая XOR результат функции G от правой и ключа
        R = L ^ G(R, round_keys[i])
        # Новая левая часть: старая правая
        L = old_R

    # Собираем расшифрованный блок: сначала R, затем L
    decrypted: bytes = R.to_bytes(4, 'big') + L.to_bytes(4, 'big')

    # Возвращаем 8 байт расшифрованного блока
    return decrypted


def process_file(input_file: str, output_file: str, key: bytes, mode: str = "encrypt") -> None:
    """
    Обрабатывает файл: шифрует или расшифровывает его поблочно.
    Аргументы:
        input_file (str): Путь к входному файлу.
        output_file (str): Путь к выходному файлу.
        key (bytes): Ключ шифрования (256 бит).
        mode (str): Режим работы ('encrypt' или 'decrypt').
    Обработка ошибок: FileNotFoundError: Если входной файл не найден.
    """
    # Генерируем раундовые ключи из исходного ключа
    round_keys: List[int] = generate_round_keys(key)

    # Открываем входной файл в бинарном режиме для чтения
    with open(input_file, 'rb') as f_in:
        # Открываем выходной файл в бинарном режиме для записи
        with open(output_file, 'wb') as f_out:
            # Бесконечный цикл для чтения файла поблочно
            while True:
                # Читаем очередной блок размером 64 бита (8 байт)
                block: bytes = f_in.read(8)
                # Если блок пустой (конец файла), выходим из цикла
                if not block:
                    break
                # Если блок меньше 8 байт (последний блок), дополняем нулями
                if len(block) < 8:
                    block += b'\x00' * (8 - len(block))
                # Выбираем режим обработки
                if mode == "encrypt":
                    # Шифруем блок
                    result: bytes = encrypt_block(block, round_keys)
                else:
                    # Расшифровываем блок
                    result: bytes = decrypt_block(block, round_keys)
                # Записываем результат в выходной файл
                f_out.write(result)


def main() -> None:
    """
    Основная функция программы: запрашивает у пользователя параметры и запускает обработку файла.
    """
    # Выводим приветственное сообщение
    print("Программа шифрования/расшифрования с использованием шифра Магма")
    print("-----------------------------------------------------------")

    # Запрашиваем режим работы у пользователя
    while True:
        # Получаем ввод и убираем лишние пробелы, приводим к нижнему регистру
        mode: str = input("Выберите режим (encrypt/decrypt): ").strip().lower()
        # Проверяем, что введён корректный режим
        if mode in ["encrypt", "decrypt"]:
            break
        # Если режим неверный, выводим сообщение об ошибке
        print("Ошибка: введите 'encrypt' или 'decrypt'")

    # Запрашиваем путь к входному файлу
    while True:
        # Получаем путь к файлу и убираем лишние пробелы
        input_file: str = input("Введите путь к входному файлу: ").strip()
        # Проверяем, существует ли файл
        if os.path.exists(input_file):
            break
        # Если файла нет, выводим ошибку
        print("Ошибка: файл не найден")

    # Запрашиваем путь к выходному файлу
    output_file: str = input("Введите путь к выходному файлу: ").strip()

    # Запрашиваем ключ шифрования
    while True:
        # Получаем ключ в виде hex-строки
        key_hex: str = input("Введите ключ (256 бит в hex, 64 символа): ").strip()
        try:
            # Преобразуем hex-строку в байты
            key: bytes = bytes.fromhex(key_hex)
            # Проверяем, что длина ключа ровно 32 байта (256 бит)
            if len(key) == 32:
                break
            # Если длина неверная, выводим ошибку
            print("Ошибка: ключ должен быть длиной 256 бит (64 символа в hex)")
        except ValueError:
            # Если строка не в формате hex, выводим ошибку
            print("Ошибка: неверный формат hex-строки")

    # Выполняем обработку файла
    try:
        # Запускаем шифрование или расшифрование
        process_file(input_file, output_file, key, mode)
        # Сообщаем об успешном завершении
        print(f"Операция завершена! Результат сохранён в {output_file}")
    except Exception as e:
        # Если произошла ошибка (например, файл не открылся), выводим её
        print(f"Произошла ошибка: {e}")


# запуск
if __name__ == "__main__":
    # Вызываем основную функцию при запуске скрипта
    main()