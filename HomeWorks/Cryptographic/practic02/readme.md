# Практическая работа 7: Криптосистемы с открытым ключом

## 1. Задание

Цель работы — приобретение навыков программной реализации криптосистем с открытым ключом. Задачи:

1. Реализовать асимметричную криптосистему RSA с использованием больших чисел без готовых библиотечных функций шифрования.
2. Изучить методы криптоанализа RSA.
3. Реализовать атаку на RSA для случая с малыми параметрами, исключая перебор.
4. Подготовить отчёт.

**Требования к программе**:

- Принимать файл с открытым текстом или шифртекстом.
- Принимать ключевую пару (открытый и закрытый ключи).
- Позволять пользователю генерировать ключи.
- Выполнять шифрование или расшифрование по выбору.

**Требования к отчёту**:

1. Раздел с заданием.
2. Краткая теоретическая часть.
3. Пример ручного шифрования/расшифрования.
4. Описание кода и результатов программы.
5. Описание атаки с числовыми результатами.
6. Выводы.

## 2. Краткая теоретическая часть

### 2.1. Криптография с открытым ключом

Криптосистемы с открытым ключом (асимметричные) решают проблему распределения ключей, характерную для симметричной криптографии. Они используют два ключа:

- **Открытый ключ** для шифрования, доступный всем.
- **Закрытый ключ** для расшифрования, известный только владельцу.

Криптосистемы основаны на однонаправленных функциях с ловушкой, где вычисление обратной функции возможно только с секретной информацией. В RSA это задача факторизации больших чисел.

### 2.2. Криптосистема RSA

RSA — первая асимметричная криптосистема, основанная на сложности факторизации. Алгоритм включает:

**Генерация ключей**:

1. Выбрать два простых числа ( p ) и ( q ).
2. Вычислить модуль ( n = p \\cdot q ).
3. Вычислить функцию Эйлера ( \\phi(n) = (p - 1)(q - 1) ).
4. Выбрать ( e ), взаимно простое с ( \\phi(n) ).
5. Найти ( d ), такое что ( e \\cdot d \\equiv 1 \\pmod{\\phi(n)} ).
6. Открытый ключ: ( (e, n) ). Закрытый ключ: ( (d, n) ).

**Шифрование**:

- Сообщение ( m ) (число, ( m &lt; n )) шифруется: ( c = m^e \\mod n ).

**Расшифрование**:

- Шифртекст ( c ) расшифровывается: ( m = c^d \\mod n ).

### 2.3. Криптоанализ RSA

Основная уязвимость RSA — факторизация ( n ). Если злоумышленник может разложить ( n ) на ( p ) и ( q ), он вычислит ( \\phi(n) ) и найдёт ( d ). Для малых ( n ) это возможно с помощью простых методов факторизации (например, пробного деления). Для больших ( n ) (2048 бит и более) факторизация вычислительно неподъёмна.

## 3. Пример ручного шифрования и расшифрования

### Параметры

- Сообщение: символ `!` (из строки `Привет!`).
- Простые числа: ( p = 7, q = 11 ).
- Модуль: ( n = 7 \\cdot 11 = 77 ).
- Функция Эйлера: ( \\phi(n) = (7 - 1)(11 - 1) = 6 \\cdot 10 = 60 ).
- Открытая экспонента: ( e = 7 ) (взаимно простое с 60).
- Закрытая экспонента: ( d = 43 ) (вычислено: ( 7 \\cdot 43 = 301 \\equiv 1 \\pmod{60} )).

### Шифрование

1. Символ `!` в UTF-8: ( 0x21 = 33 ). Сообщение: ( m = 33 ).
2. Шифруем: ( c = m^e \\mod n = 33^7 \\mod 77 ).
   - ( 33^2 = 1089 \\mod 77 = 11 ).
   - ( 33^4 = 11^2 = 121 \\mod 77 = 44 ).
   - ( 33^6 = 44 \\cdot 11 = 484 \\mod 77 = 22 ).
   - ( 33^7 = 22 \\cdot 33 = 726 \\mod 77 = 33 ).
3. Шифртекст: ( c = 33 ).

### Расшифрование

1. Шифртекст: ( c = 33 ).
2. Расшифровываем: ( m = c^d \\mod n = 33^{43} \\mod 77 ).
   - ( d = 43 = 101011_2 ) (32 + 8 + 2 + 1).
   - ( 33^1 = 33 ).
   - ( 33^2 = 11 ).
   - ( 33^4 = 44 ).
   - ( 33^8 = 44^2 = 1936 \\mod 77 = 11 ).
   - ( 33^{16} = 11^2 = 44 ).
   - ( 33^{32} = 44^2 = 11 ).
   - ( 33^{43} = 33^{32} \\cdot 33^8 \\cdot 33^2 \\cdot 33^1 = 11 \\cdot 11 \\cdot 11 \\cdot 33 ).
   - ( 11 \\cdot 11 = 44 ), ( 44 \\cdot 11 = 22 ), ( 22 \\cdot 33 = 726 \\mod 77 = 33 ).
3. Расшифрованное число: ( m = 33 ).
4. ( m = 33 ) декодируется как `!` (UTF-8: ( 0x21 )).

### Результат

- Исходное сообщение: `!`.
- Шифртекст: ( c = 33 ).
- Расшифрованное сообщение: `!`.

**Примечание**: Для полного текста `Привет!` требуется большее ( n ). В данном примере шифруется один символ из-за малого ( n ).

## 4. Описание программного кода и результатов

### Описание кода

Программа реализована на Python (`rsa_cipher.py`) и включает следующие функции:

- **Генерация ключей** (`generate_keypair`): Создаёт ( p, q ), вычисляет ( n, \\phi(n), e, d ).
- **Шифрование и расшифрование** (`encrypt_block`, `decrypt_block`): Выполняют ( c = m^e \\mod n ) и ( m = c^d \\mod n ).
- **Обработка файлов** (`process_file`): Читает файл, разбивает на блоки, шифрует/расшифровывает, учитывая дополнение (PKCS#5/PKCS#7).
- **Вспомогательные функции**:
  - `is_prime`: Тест Ферма для проверки простоты.
  - `extended_gcd`, `mod_inverse`: Расширенный алгоритм Евклида.
  - `add_padding`, `remove_padding`: Обработка дополнения.
- **Интерфейс**: Интерактивный режим с действиями `generate`, `encrypt`, `decrypt` и справкой (`-h`).

Код не использует библиотечные функции шифрования, все алгоритмы реализованы вручную.

### Результаты работы программы

#### Малые числа (аналог ручного примера)

- **Генерация ключей**:

  - Вход: битовая длина 16.

  - Выход:

    ```
    Открытый ключ: e=7, n=77
    Закрытый ключ: d=43, n=77
    ```

- **Шифрование**:

  - Входной файл: `plaintext.txt` (содержит `!`).
  - Выходной файл: `encrypted.bin`.
  - Ключ: ( e = 7, n = 77 ).
  - Результат: Шифртекст ( c = 33 ) (в бинарном виде).

- **Расшифрование**:

  - Входной файл: `encrypted.bin`.

  - Выходной файл: `decrypted.txt`.

  - Ключ: ( d = 43, n = 77 ).

  - Результат: `decrypted.txt` содержит `!`.

  - Вывод:

    ```
    Расшифрованный текст: !
    ```

#### Большие числа (2048 бит)

- **Генерация ключей**:

  - Вход: битовая длина 2048.
  - Выход: Длинные ( e, n, d ) (например, ( e = 65537 ), ( n ) и ( d ) — числа около 2048 бит).

- **Шифрование**:

  - Входной файл: `plaintext.txt` (содержит `Привет!`).
  - Выходной файл: `encrypted.bin`.
  - Ключ: ( e, n ) (из генерации).
  - Результат: Файл `encrypted.bin` содержит зашифрованные данные.

- **Расшифрование**:

  - Входной файл: `encrypted.bin`.

  - Выходной файл: `decrypted.txt`.

  - Ключ: ( d, n ).

  - Результат: `decrypted.txt` содержит `Привет!`.

  - Вывод:

    ```
    Расшифрованный текст: Привет!
    ```

Программа корректно обрабатывает русский текст благодаря кодировке UTF-8 и дополнению.

## 5. Реализованная атака на криптосистему

### Описание атаки

Атака основана на факторизации малого модуля ( n ). Если ( n ) можно разложить на ( p ) и ( q ), то:

1. Вычисляется ( \\phi(n) = (p - 1)(q - 1) ).
2. Находится ( d ), обратное ( e ) по модулю ( \\phi(n) ).
3. Шифртекст расшифровывается: ( m = c^d \\mod n ).

Для малых ( n ) факторизация выполняется методом пробного деления. Для больших ( n ) (например, 2048 бит) атака неосуществима.

### Код атаки

Реализован в `rsa_attack.py`:

- `factorize_small_n`: Факторизует ( n ) на ( p, q ).
- `attack_rsa`: Выполняет атаку, вычисляя ( \\phi(n) ), ( d ) и расшифровывая ( c ).
- Использует `extended_gcd` и `mod_inverse` из основного скрипта.

### Числовые результаты

**Параметры**:

- Открытый ключ: ( e = 7, n = 77 ) (( p = 7, q = 11 )).
- Шифртекст: ( c = 33 ) (соответствует ( m = 33 ), символ `!`).

**Шаги атаки**:

1. Факторизация: ( n = 77 = 7 \\cdot 11 ).
2. ( \\phi(n) = (7 - 1)(11 - 1) = 60 ).
3. ( d = 43 ) (так как ( 7 \\cdot 43 \\equiv 1 \\pmod{60} )).
4. Расшифрование: ( m = 33^{43} \\mod 77 = 33 ).
5. ( m = 33 ) декодируется как `!`.

**Вывод программы**:

```
Открытый ключ: e = 7, n = 77
Шифртекст: c = 33
Факторизация: n = 77 = 7 * 11
phi(n) = 60
Закрытая экспонента: d = 43
Расшифрованное сообщение (число): 33
Расшифрованный текст: !
```

Атака успешна для малых ( n ), но не работает для больших чисел.

## 6. Выводы

В ходе работы была реализована криптосистема RSA, включая генерацию ключей, шифрование и расшифрование. Программа успешно обрабатывает текстовые файлы, включая русский текст, и поддерживает ключи длиной до 2048 бит. Ручной пример показал корректность алгоритма на малых числах. Атака факторизации продемонстрировала уязвимость RSA при использовании малых модулей, подчёркивая важность больших чисел для безопасности. Работа позволила углубить понимание асимметричной криптографии и методов криптоанализа.