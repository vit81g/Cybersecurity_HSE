import os  # Импортируем модуль os для работы с файлами

# Фиксированная таблица замен (S-box) из ГОСТ Р 34.12-2015, Приложение А
# 8 строк по 16 значений, применяется для подстановки 4-битовых кусков
SBOX = [
    [12, 4, 6, 2, 10, 5, 11, 9, 14, 8, 13, 7, 0, 3, 15, 1],  # \(\pi_0\)
    [6, 8, 2, 3, 9, 10, 5, 12, 1, 11, 7, 13, 0, 4, 15, 14],   # \(\pi_1\)
    [7, 11, 5, 8, 12, 4, 2, 0, 14, 1, 3, 10, 9, 15, 6, 13],   # \(\pi_2\)
    [13, 1, 7, 4, 11, 5, 0, 15, 3, 12, 14, 6, 9, 10, 2, 8],   # \(\pi_3\)
    [5, 10, 15, 12, 1, 13, 14, 11, 8, 3, 6, 0, 4, 7, 9, 2],   # \(\pi_4\)
    [14, 5, 0, 15, 13, 11, 3, 6, 9, 2, 12, 7, 1, 8, 10, 4],   # \(\pi_5\)
    [11, 13, 12, 3, 7, 14, 10, 5, 0, 9, 4, 15, 2, 8, 1, 6],   # \(\pi_6\)
    [15, 12, 9, 7, 3, 0, 11, 4, 1, 14, 2, 13, 6, 10, 8, 5]    # \(\pi_7\)
]

# Функция генерации раундовых ключей из исходного ключа
def generate_round_keys(key):
    # Проверяем, что ключ — 256 бит (32 байта)
    if len(key) != 32:
        raise ValueError("Ключ должен быть длиной 256 бит (32 байта)")
    round_keys = []  # Список для хранения 8 ключей по 32 бита
    # Делим ключ на 8 частей по 4 байта
    for i in range(0, 32, 4):
        # Преобразуем 4 байта в 32-битовое число (big-endian)
        k = int.from_bytes(key[i:i+4], 'big')
        round_keys.append(k)  # Добавляем в список
    # Порядок ключей: первые 24 раунда — ключи 0-7 трижды, последние 8 — 7-0
    schedule = round_keys * 3 + round_keys[::-1]
    return schedule  # Возвращаем 32 раундовых ключа

# Функция G — преобразование в сети Фейстеля
def G(a, k):
    # a — правая часть блока (32 бита), k — раундовый ключ
    # Складываем a и k по модулю 2^32
    t = (a + k) % (2**32)
    # Циклический сдвиг влево на 11 бит
    t = ((t << 11) | (t >> 21)) & 0xFFFFFFFF  # Маска для 32 бит
    result = 0  # Переменная для результата подстановки
    # Применяем SBOX к каждому 4-битовому куску
    for i in range(8):
        # Берем i-й 4-битовый кусок из t
        nibble = (t >> (4 * i)) & 0xF
        # Выполняем подстановку из таблицы
        subst = SBOX[i][nibble]
        # Собираем результат
        result |= (subst << (4 * i))
    return result  # Возвращаем преобразованное значение

# Функция шифрования одного блока (64 бита)
def encrypt_block(block, round_keys):
    # Проверяем длину блока — должен быть 64 бита (8 байт)
    if len(block) != 8:
        raise ValueError("Блок должен быть длиной 64 бита (8 байт)")
    # Делим блок на левую (L) и правую (R) части по 32 бита
    L = int.from_bytes(block[:4], 'big')  # Первые 4 байта
    R = int.from_bytes(block[4:], 'big')  # Последние 4 байта
    # 32 раунда сети Фейстеля
    for i in range(32):
        old_R = R  # Сохраняем старую правую часть
        R = L ^ G(R, round_keys[i])  # Новая правая: L XOR G(R, ключ)
        L = old_R  # Новая левая: старая правая
    # Собираем зашифрованный блок: R|L
    encrypted = R.to_bytes(4, 'big') + L.to_bytes(4, 'big')
    return encrypted

# Функция расшифрования одного блока (64 бита)
def decrypt_block(block, round_keys):
    # Проверяем длину блока — должен быть 64 бита (8 байт)
    if len(block) != 8:
        raise ValueError("Блок должен быть длиной 64 бита (8 байт)")
    # Делим блок на левую (L) и правую (R) части по 32 бита
    L = int.from_bytes(block[:4], 'big')  # Первые 4 байта
    R = int.from_bytes(block[4:], 'big')  # Последние 4 байта
    # 32 раунда в обратном порядке ключей
    for i in range(31, -1, -1):
        old_R = R  # Сохраняем старую правую часть
        R = L ^ G(R, round_keys[i])  # Новая правая: L XOR G(R, ключ)
        L = old_R  # Новая левая: старая правая
    # Собираем расшифрованный блок: R|L
    decrypted = R.to_bytes(4, 'big') + L.to_bytes(4, 'big')
    return decrypted

# Функция обработки файла
def process_file(input_file, output_file, key, mode="encrypt"):
    # Генерируем раундовые ключи
    round_keys = generate_round_keys(key)
    # Открываем входной файл для чтения
    with open(input_file, 'rb') as f_in:
        # Открываем выходной файл для записи
        with open(output_file, 'wb') as f_out:
            while True:
                # Читаем блок данных (64 бита = 8 байт)
                block = f_in.read(8)
                # Если данных нет, выходим
                if not block:
                    break
                # Дополняем блок нулями, если он меньше 8 байт
                if len(block) < 8:
                    block += b'\x00' * (8 - len(block))
                # Выбираем режим
                if mode == "encrypt":
                    result = encrypt_block(block, round_keys)  # Шифруем
                else:
                    result = decrypt_block(block, round_keys)  # Расшифровываем
                # Записываем результат
                f_out.write(result)

# Основная функция программы с пользовательским вводом
def main():
    print("Программа шифрования/расшифрования с использованием шифра Магма")
    print("-----------------------------------------------------------")

    # Запрашиваем у пользователя режим работы
    while True:
        mode = input("Выберите режим (encrypt/decrypt): ").strip().lower()
        if mode in ["encrypt", "decrypt"]:
            break
        print("Ошибка: введите 'encrypt' или 'decrypt'")

    # Запрашиваем путь к входному файлу
    while True:
        input_file = input("Введите путь к входному файлу: ").strip()
        if os.path.exists(input_file):
            break
        print("Ошибка: файл не найден")

    # Запрашиваем путь к выходному файлу
    output_file = input("Введите путь к выходному файлу: ").strip()

    # Запрашиваем ключ (ожидаем 256 бит = 64 символа в hex)
    while True:
        key_hex = input("Введите ключ (256 бит в hex, 64 символа): ").strip()
        try:
            key = bytes.fromhex(key_hex)  # Преобразуем hex-строку в байты
            if len(key) == 32:  # Проверяем длину ключа
                break
            print("Ошибка: ключ должен быть длиной 256 бит (64 символа в hex)")
        except ValueError:
            print("Ошибка: неверный формат hex-строки")

    # Выполняем шифрование или расшифрование
    try:
        process_file(input_file, output_file, key, mode)
        print(f"Операция завершена! Результат сохранён в {output_file}")
    except Exception as e:
        print(f"Произошла ошибка: {e}")

# Запуск программы
if __name__ == "__main__":
    main()  # Вызываем основную функцию
